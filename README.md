# Итоговая контрольная работа по основному блоку

## Условие задачи
Написать программу, которая из имеющегося массива строк формирует новый массив из строк, длина которых меньше, либо равна 3 символам. Первоначальный массив можно ввести с клавиатуры, либо задать на старте выполнения алгоритма. При решении не рекомендуется пользоваться коллекциями, лучше обойтись исключительно массивами.

### Примеры:

<em> [“Hello”, “2”, “world”, “:-)”] → [“2”, “:-)”]

[“1234”, “1567”, “-2”, “computer science”] → [“-2”]

[“Russia”, “Denmark”, “Kazan”] → []  </em>

## Подзадачи
1. Создать репозиторий на GitHub
2. Нарисовать блок-схему алгоритма (можно обойтись блок-схемой основной содержательной части, если вы выделяете её в отдельный метод)
3. Снабдить репозиторий оформленным текстовым описанием решения (файл README.md)
4. Написать программу, решающую поставленную задачу
5. Использовать контроль версий в работе над этим небольшим проектом (не должно быть так, что всё залито одним коммитом, как минимум этапы 2, 3, и 4 должны быть расположены в разных коммитах)


## Выполнение работы

### Задание 1
https://github.com/MihaylovaEA/ControlWork1.git

### Задание 2
Файл Algorithm.png

### Задание 3
Программа включает в себя 4 метода:
1. *CreateArrayUserString(int size)*

    Метод создания массива. Элементы вводятся пользователем с клавиатуры.
2. *PrintArrayString(string[] arr)*

    Метод вывода массива в консоль.
3. *CountElementsFixLen(string[] arr, int len)*

    Метод подсчета элементов фиксированной длины. Необходим для нахождения длины результирующего массива. При необходимости можно объединить данный метод с методом NewArrayWithElementsFixLen(string[] arr, int len, int count).

    Подсчет количества элементов выполняется следующим образом:

    Инициализируем вспомогательную переменную *count = 0*.

    В цикле проходим по каждому элементу массива. 

    На каждой итерации проверяем выполнение условия "Длина элемента меньше или равна заданной длины *len*".

    Если условие выполнено, то инкрементируем ранее инициализируемую переменную *count* и переходим к следующему элементу массива.
    
    Если условие не выполнено, то инкрементируем только счетчик цикла.
4. *NewArrayWithElementsFixLen(string[] arr, int len, int count)*

    Метод создания результирующего массива с элементами фиксированной длины. На вход передаем исходный массив, длину элементов и количество элементов конечного массива.

    Инициализируем новый массив.

    Инициализируем вспомогательную переменную *j = 0*.

    В цикле по всем элементам исходного массива проверяем условие "Длина элемента меньше или равна заданной длины *len*".

    Если условие выполнено, то сохраняем данный элемент исходного массива в новый массив на позицию j, инкрементируем ранее инициализируемую переменную *j* и переходим к следующему элементу исходного масиива.

    Если условие не выполнено, то сразу переходим к следующему элементу исходного массива.

Основной алгорим программы:
1. Запрашиваем у пользователя длину массива *size*.
2. Инициализируем массив *startArray*.
3. Приглашаем пользователя ко вводу элементов массива. Сохраняем введенные данные в массив *startArray*, используя метод 1.
4. Инициализируем вспомогательную перемнную *countElementsFixLen*. Сохраняем в нее количество элементов массива фиксированной длины (в нашем случае 3), исользуя метод 3.
5. Инициализируем результирующий массив *finalArray*. Сохраняем в него массив, полученный в методе 4.
6. Выводим конечный массив *finalArray* в консоль, используя метод 2.

### Задание 4
Программа располагается в папке Task.